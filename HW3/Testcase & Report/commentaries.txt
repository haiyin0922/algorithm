Since level1 is strictly weaker than level2, and so is level2 weaker than level3, if your program fails on
any testcase of an easier level, you won't get the points from the harder level either.

Level1 is really simple. You only need to maintain the dp table naively in O(N**2).

However, many had the wrong dp table which seems to be O(N), and indeed is, but would produce wrong answers.

The most common error is disregarding either the fact that you don't know how many days you have been
sleeping in the "optimal" state you are trying to transfer from, or you are somehow forcing yourself
into limited choices.

Level2 actually wasn't meant to be hard, but it seems like no one figured it out and analyzed it correctly.

However, there were some who accidentally implemented the idea without noticing its worst case is better
than O(N**2).

The main idea is to notice that, when b > 0, you could always find an optimal transfering from within 
O(sqrt((max(D) + A) / B)) days.

That would significantly reduce the cost of updating the dp table, and result in an algorithm with complexity
O(sqrt((max(D) + A) / B) * N).

Also, noticing that the optimal transfering index monotonically increases could make your implementation easier.

The optimization used in level2 depends on the values. However, in level3 the values have gone higher. 

The expected solution is O(N lg N) or O(N). 

Since the optimal transfering index is monotonically increasing, you could maintain the optimal transfering
index in a smart way (see `Dynamic programming with convexity, concavity and sparsity` - 1D/1D problem).

To achieve O(N), you could reform the transfering equation into linear equations, and transfer the problem
into maintaining linear equations to efficiently query minimum value given any parameter (as known as
the Convex hull trick). See the attached report for details. 

